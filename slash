#!/usr/bin/env python3
"""
Remote Command Executor - MANDATORY
All commands are fetched from AssetUtilities on GitHub
"""

import os
import sys
import json
import subprocess
import urllib.request
from pathlib import Path
from typing import Optional, Dict, Any

class RemoteCommandExecutor:
    """
    Executes slash commands by fetching them from AssetUtilities
    This ensures all repos use the SAME command implementations
    """
    
    def __init__(self):
        self.repo_path = Path.cwd()
        self.link_file = self.repo_path / ".command-link"
        self.config = self.load_config()
        
    def load_config(self) -> Dict:
        """Load command link configuration"""
        if not self.link_file.exists():
            raise FileNotFoundError(
                "‚ùå .command-link not found! This repo is not properly linked to AssetUtilities"
            )
        
        with open(self.link_file, 'r') as f:
            return json.load(f)
    
    def fetch_command_registry(self) -> Dict:
        """Fetch command registry from AssetUtilities"""
        registry_url = f"{self.config['raw_url']}/{self.config['command_path']}/command_registry.py"
        
        try:
            with urllib.request.urlopen(registry_url) as response:
                # Execute registry to get command list
                exec_globals = {}
                exec(response.read().decode('utf-8'), exec_globals)
                return exec_globals.get('CentralCommandRegistry', {}).COMMANDS
        except Exception as e:
            print(f"‚ö†Ô∏è Could not fetch registry from GitHub: {e}")
            return self.get_local_fallback()
    
    def get_local_fallback(self) -> Dict:
        """Fallback to local AssetUtilities if GitHub unavailable"""
        local_asset = Path("/mnt/github/github/assetutilities")
        registry_file = local_asset / ".common-commands" / "command_registry.py"
        
        if registry_file.exists():
            exec_globals = {}
            exec(registry_file.read_text(), exec_globals)
            return exec_globals.get('CentralCommandRegistry', {}).COMMANDS
        
        return {}
    
    def fetch_and_execute(self, command: str, args: list) -> int:
        """Fetch command from AssetUtilities and execute it"""
        
        # Get command registry
        commands = self.fetch_command_registry()
        
        if command not in commands:
            print(f"‚ùå Unknown command: {command}")
            print("\nAvailable commands from AssetUtilities:")
            for cmd, info in commands.items():
                print(f"  {cmd}: {info['description']}")
            return 1
        
        cmd_info = commands[command]
        
        # Determine if command is local or global scope
        if cmd_info['scope'] == 'local':
            # Execute in current repo context
            return self.execute_local_command(command, cmd_info, args)
        else:
            # Execute globally
            return self.execute_global_command(command, cmd_info, args)
    
    def execute_local_command(self, command: str, cmd_info: Dict, args: list) -> int:
        """Execute command in local repository context"""
        module_url = f"{self.config['raw_url']}/{self.config['command_path']}/modules/{cmd_info['module']}.py"
        
        try:
            # Fetch module from GitHub
            with urllib.request.urlopen(module_url) as response:
                module_code = response.read().decode('utf-8')
            
            # Execute in current context
            exec_globals = {'__name__': '__main__', 'sys': sys, 'os': os}
            exec(module_code, exec_globals)
            
            # Call the function
            func = exec_globals.get(cmd_info['function'])
            if func:
                return func(args)
            else:
                print(f"‚ùå Function {cmd_info['function']} not found in module")
                return 1
                
        except Exception as e:
            print(f"‚ùå Error executing {command}: {e}")
            # Try local fallback
            return self.execute_local_fallback(command, args)
    
    def execute_global_command(self, command: str, cmd_info: Dict, args: list) -> int:
        """Execute command globally (all repos)"""
        # For global commands, we need to execute from assetutilities context
        asset_path = Path("/mnt/github/github/assetutilities")
        
        if not asset_path.exists():
            print("‚ùå AssetUtilities repository not found locally")
            return 1
        
        # Execute from assetutilities
        cmd = f"cd {asset_path} && python3 .common-commands/command_registry.py {command} {' '.join(args)}"
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        
        print(result.stdout)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
        
        return result.returncode
    
    def execute_local_fallback(self, command: str, args: list) -> int:
        """Fallback to local command execution"""
        # Try to find local implementation
        local_cmd_file = self.repo_path / ".git-commands" / "slash_commands.py"
        
        if local_cmd_file.exists():
            cmd = f"python3 {local_cmd_file} {command.replace('/', '')} {' '.join(args)}"
            result = subprocess.run(cmd, shell=True)
            return result.returncode
        
        print("‚ùå No local fallback available")
        return 1
    
    def update_from_central(self) -> bool:
        """Update local command cache from AssetUtilities"""
        print("üîÑ Updating commands from AssetUtilities...")
        
        try:
            # Update link timestamp
            self.config['last_sync'] = datetime.now().isoformat()
            with open(self.link_file, 'w') as f:
                json.dump(self.config, f, indent=2)
            
            print("‚úÖ Commands updated from AssetUtilities")
            return True
            
        except Exception as e:
            print(f"‚ùå Update failed: {e}")
            return False


def main():
    """Main entry point for slash command execution"""
    if len(sys.argv) < 2:
        print("Usage: slash <command> [args...]")
        print("\nThis repo is linked to AssetUtilities for all commands")
        print("Commands are fetched from GitHub in real-time")
        return 1
    
    command = sys.argv[1]
    if not command.startswith('/'):
        command = f"/{command}"
    
    args = sys.argv[2:] if len(sys.argv) > 2 else []
    
    executor = RemoteCommandExecutor()
    
    # Special command to update from central
    if command == "/update-from-central":
        return 0 if executor.update_from_central() else 1
    
    return executor.fetch_and_execute(command, args)


if __name__ == "__main__":
    from datetime import datetime
    sys.exit(main())
